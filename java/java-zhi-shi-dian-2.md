# java知识点(2)

### 面向对象和面向过程的区别

两者的主要区别在于解决问题的方式不同：

* 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
* 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

另外，面向对象开发的程序一般更易维护、易复用、易扩展。

### 方法（函数）

```java
方法的声明：权限修饰符  返回值类型 方法名(形参列表){
				方法体
}
```

默认方法的权限修饰符先都使用public

Java规定的4种权限修饰符：private、public、缺省、protected

#### 返回值类型：

1. 没返回值 void return;表示结束此方法
2. 有返回值 return 数据

#### 形参列表：

方法可以声明0个，1个，或多个形参。格式：数据类型1 形参1,数据类型2 形参2,...

方法的使用中：

1. 可以调用当前类的属性或方法
2. 特殊的：方法A中又调用了方法A:递归
3. 方法中，不可以定义方法

### 类 对象

```java
public class Dog{
 
  String breed;
  int age;
  String color;
 
  void barking(){
 
  }
 
  void hungry(){
 
  }
 
  void sleeping(){
 
  }
 
}
```

* **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。**不可以使用权限修饰符**。加载到栈空间
* **成员变量/属性**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。加载到堆空间
*   **类变量/静态变量/全局变量**：类变量也声明在类中，方法体之外，但必须声明为static类型。加载到方法区

    <img src="https://cdn.jsdelivr.net/gh/YZJss/tuchuang@main/img2.jpg" alt="img" data-size="original">

#### 创建对象

对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：

* **声明**：声明一个对象，包括对象名称和对象类型。
* **实例化**：使用关键字new来创建一个对象。
* **初始化**：使用new创建对象时，会调用构造方法初始化对象。

#### 匿名对象

创建的对象，没显式的赋给一个变量名。即为匿名对象

特点：匿名对象只能调用一次。

### 构造器（构造方法）Constructor

#### 构造器的作用

1.创建对象

2.初始化对象的信息

使用说明：

1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器

2.定义构造器的格式：**权限修饰符 类名(形参列表){}**

3.一个类中定义的多个构造器，彼此构成重载

4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器

5.一个类中，至少会有一个构造器。

#### 构造方法有哪些特点？是否可被 override?

特点：

1. 名字与类名相同。
2. 没有返回值，但不能用 void 声明构造函数。
3. 生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

### 封装

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

```java
public class Student {
    private int id;//id属性私有化
    private String name;//name属性私有化

    //获取id的方法
    public int getId() {
        return id;
    }

    //设置id的方法
    public void setId(int id) {
        this.id = id;
    }

    //获取name的方法
    public String getName() {
        return name;
    }

    //设置name的方法
    public void setName(String name) {
        this.name = name;
    }
}
```

将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值。

![img5](https://cdn.jsdelivr.net/gh/YZJss/tuchuang@main/img5.jpeg)

### 继承

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

```java
class B {
}
class A extends B {
}
//A:子类、派生类、subclass
//B:父类、超类、基类、superclass
```

#### 继承性的好处？

1. 减少了代码的冗余，提高了代码的复用性
2. 便于功能的扩展
3. 为之后多态性的使用，提供了前提

**说明**

1. 一个类可以被多个子类继承。
2. Java中类的单继承性：一个类只能有一个父类
3. 子父类是相对的概念
4. 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
5. 子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法

### 关键字：super

可以调用属性、方法、构造器。

**super调用属性、方法：**

1. 可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
2. 特殊情况：当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
3. 特殊情况：当子类重写了父类中的方法以后，要想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。

**super调用构造器：**

1. 可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器。
2. "super(形参列表)"的使用，必须声明在子类构造器的首行。
3. 在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"不能同时出现。
4. 在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
5. 在类的多个构造器中，至少一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器。

### 关键字：this

this理解为当前对象 或 当前正在创建的对象。

指向自己的引用

### 重写(Override或overwrite)

子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。

重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

**重写的规则：**

① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符

特殊情况：子类不能重写父类中声明为private权限的方法

③ 返回值类型：

父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void

父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类

父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)

子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。

子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。

声明为 final 的方法不能被重写。

### 重载

定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

总结："两同一不同":同一个类、相同方法名

参数列表不同：参数个数不同，参数类型不同

### 多态

对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

**多态存在的三个必要条件**

* 继承
* 重写
* 父类引用指向子类对象

**多态性的使用：虚拟方法调用**

有了对象的多态性以后，在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

总结：编译，看左边；运行，看右边。

**注意**

对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）
